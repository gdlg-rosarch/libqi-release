From 9b37a266096d9a11cbe25b6e6bce33cf7902715e Mon Sep 17 00:00:00 2001
From: Surya Ambrose <surya.ambrose@gmail.com>
Date: Wed, 6 Dec 2017 19:26:53 +0000
Subject: [PATCH 7/7] Fix boost compilation for 1.62

---
 qi/detail/executioncontext.hpp       | 8 ++++----
 qi/type/detail/listtypeinterface.hxx | 2 +-
 qi/type/detail/object.hxx            | 8 ++++----
 3 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/qi/detail/executioncontext.hpp b/qi/detail/executioncontext.hpp
index fa9a5f20..e5709132 100644
--- a/qi/detail/executioncontext.hpp
+++ b/qi/detail/executioncontext.hpp
@@ -53,14 +53,14 @@ public:
   /// call a callback asynchronously to be executed in delay
   /// @deprecated since 2.5
   template <typename R>
-  QI_API_DEPRECATED typename boost::disable_if<boost::is_same<R, void>,
+  QI_API_DEPRECATED typename boost::disable_if<std::is_same<R, void>,
                               qi::Future<R> >::type
       async(const boost::function<R()>& callback,
           qi::Duration delay);
   /// call a callback asynchronously to be executed on tp
   /// @deprecated since 2.5
   template <typename R>
-  QI_API_DEPRECATED typename boost::disable_if<boost::is_same<R, void>,
+  QI_API_DEPRECATED typename boost::disable_if<std::is_same<R, void>,
                               qi::Future<R> >::type
       async(const boost::function<R()>& callback, qi::SteadyClockTimePoint tp);
 
@@ -157,7 +157,7 @@ void checkCanceled(qi::Future<void> f, qi::Promise<R> p)
 }
 
 template <typename R>
-typename boost::disable_if<boost::is_same<R, void>,
+typename boost::disable_if<std::is_same<R, void>,
                             qi::Future<R> >::type
     ExecutionContext::async(const boost::function<R()>& callback,
                             qi::Duration delay)
@@ -174,7 +174,7 @@ typename boost::disable_if<boost::is_same<R, void>,
 }
 
 template <typename R>
-typename boost::disable_if<boost::is_same<R, void>,
+typename boost::disable_if<std::is_same<R, void>,
                             qi::Future<R> >::type
     ExecutionContext::async(const boost::function<R()>& callback,
                             qi::SteadyClockTimePoint tp)
diff --git a/qi/type/detail/listtypeinterface.hxx b/qi/type/detail/listtypeinterface.hxx
index 6cca7d56..6ba7dcc8 100644
--- a/qi/type/detail/listtypeinterface.hxx
+++ b/qi/type/detail/listtypeinterface.hxx
@@ -119,7 +119,7 @@ size_t ListTypeInterfaceImpl<T, H>::size(void* storage)
 // There is no way to register a template container type :(
 template<typename T> struct TypeImpl<std::vector<T> >: public ListTypeInterfaceImpl<std::vector<T> >
 {
-  static_assert(!boost::is_same<T,bool>::value, "std::vector<bool> is not supported by AnyValue.");
+  static_assert(!std::is_same<T,bool>::value, "std::vector<bool> is not supported by AnyValue.");
 };
 template<typename T> struct TypeImpl<std::list<T> >: public ListTypeInterfaceImpl<std::list<T> > {};
 template<typename T> struct TypeImpl<std::set<T> >: public ListTypeInterfaceImpl<std::set<T> > {};
diff --git a/qi/type/detail/object.hxx b/qi/type/detail/object.hxx
index 8b4bf12e..783cf444 100644
--- a/qi/type/detail/object.hxx
+++ b/qi/type/detail/object.hxx
@@ -216,7 +216,7 @@ public:
   // We use None to disable it. The method must be instantiable because when we
   // export the class under windows, all functions are instanciated
   // Future cast operator
-  typedef typename boost::mpl::if_<typename boost::is_same<T, Empty>::type, None, Object<Empty> >::type MaybeAnyObject;
+  typedef typename boost::mpl::if_<typename std::is_same<T, Empty>::type, None, Object<Empty> >::type MaybeAnyObject;
   Object(const qi::Future<MaybeAnyObject>& fobj);
   Object(const qi::FutureSync<MaybeAnyObject>& fobj);
 
@@ -404,7 +404,7 @@ namespace detail
 
 template<typename T> template<typename U> Object<T>::Object(boost::shared_ptr<U> other)
 { // bounce depending on T==Empty
-  _obj = detail::fromSharedPtr(*this, other, typename boost::is_same<T, Empty>::type());
+  _obj = detail::fromSharedPtr(*this, other, typename std::is_same<T, Empty>::type());
 }
 
 template<typename T> inline Object<T>::Object(T* ptr)
@@ -445,7 +445,7 @@ template<typename T> inline boost::shared_ptr<T> Object<T>::asSharedPtr()
 template<typename T> inline void Object<T>::init(detail::ManagedObjectPtr obj)
 {
   _obj = obj;
-  if (!boost::is_same<T, Empty>::value && obj)
+  if (!std::is_same<T, Empty>::value && obj)
     checkT();
   _obj = obj;
 }
@@ -465,7 +465,7 @@ template<typename T> Object<T>::operator Object<Empty>() const { return Object<E
 /// Check tha value actually has the T interface
 template<typename T> void Object<T>::checkT()
 {
-  if (boost::is_same<T, Empty>::value || !_obj)
+  if (std::is_same<T, Empty>::value || !_obj)
     return;
 
   const auto isMatchingType = [&] {
-- 
2.17.0

